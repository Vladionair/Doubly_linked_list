gAAAAABfUP5ZxtyqGQd-yvniLQlk70WibBnohCnmAmoGng8TIbdRAcvJfPHQbKcCt2zZ6AmzQvggck2VhQEFZyu7aRVoxkBdeAV-seRL82vqm4u7yGIyctH40QcylLpztYCyEfQnBttAJCX00CSDf0kawnhYdiXsXRclB8jJQA0pyJ6ay2ukmVZ7raXEp5hh6s57DEt9Z8JQJ_A_PFX6q_tksdwDCHe7WTAa_NEsOGlrPaVDoLxrmqbodV0_ekbroIPnqlxbhHYwsFDEbokxlT40o9n6hk1JoMvoVqPCXVXHddggDEoH03IU21vmXUZJZeTzdMuUOtbP69roiytMjmcnPKkR0iOCfWtF75ItJzFUrYuy5C1eYIbG7MPs6K_bMpPV-TkOKutiG6Agt1Wg6yMEGvPTxXL4kTSKtDYVIdNB-vlpYETmYD2u_lFwpKc2NaepFPCB-4KeapEpvza3T9wPPYSJVmT_xmf65_oIV7j0EaW7v_7HTQrVW--pcSs1mXaPP6mpcxqpeqJp_35b7vDMikz8rlxipIat6vJBgyUluwop42qdm6PB10sRi7UzORXVwiKtekjr_EJXD2pGeokV-MrK89ikFzXT_0v3FN-W63K_A2xTnjf_k1MlJ4uHx2eE9KM1KEF5Zs9-3jqA20dTpJ-WuE7nGKTopzqRK1f6__8ZL9m3BfPbT2oywPixZ1FFelcaDlVS_pi2SRFAYqlXtUpU-Gltg2bfC4WdLxOZcvAQaVeE5f2oVZs1TSrMi2YBs8FcN_Hq9ES5gff697bE0VhvrJsrH2Hus71m5cfwDo2_pjUmXg62Qj3APsHDrQqzJ0iAWbl5rSDepF2YKsmQkNISBfBWtvhXm3GYkTratzsjdTviMS8IBSc4_5M8in22RdZcViU7de47LC8VRtWe4XBBPkSlwHjRcAYldLtYYBHRGz8tXSDcrXZgGncz2whhFXaA_7k1u7lXQeXHrwfwn830grJ52uwdZzbQoU7A0PweNHyZj66HtStj6OijDbKhIJnwGR2jKbf1Rz10eEoLMDGAHi3d2gbeoacAB8x17amBay2GbDQAaB3VJBQ3vfaHSNoHH67E28OxLhkylpEVMwDHNShO4KqMlbPf-NvVGNyOZ0XUYvxDIjmDDckPIjrfT1WTNXYDOzoustFwRjcbuftbIzTuW1Q4p1XA85MN3HQafxx8rArW9yZFz6UiZ7GOC0guuMPH1ZdJCPiNo9j9xA3t9HKlXpPwE8FfaWWhp75uT7Wj1KupY2TgLgr96NLI9PVZywoCfKTG2xmIqMdgyzOxtPsWPiqNAOHWnw5kFNEaMFwCogKUyshL7vEAa7Bh67lXvDVeS0-qQtDgC6-hsfKZspfgNFZYTgassYfFLLomX2kvrFKHUn-mPaM0Tsg4gqfnM0eTIsnp3wnxJ3WheGq2tuwbZd4-Oq4mgFx_y31MSqxouGHzpe3fqGTl2SR9Z9Z_v8C-raqIPjGe4a8wJj_g1m9mZm3A081yqRtxNkj1AdiANXQ7aRhM6gpLRhfK3fbgLXpVv2g3aiyUVpi6w12iAHuQemBJZmNL3au2A1Zecti9TbN0nSvfmSU6iZzR8_TPcC5T6BNF9XPHqh34HOhATikCkbp2aKIuH0OteZpUavTtsjFCHaF8K5_MRsidcgopF2BcNtujs494NlLqBATJrL5Ptvnz76b-H8875-gAHg9K5XrgvovsLeXP1ZUPZW8IIOsKXp3Q84lnsK8Q4S4SrYFEuvW1AY-DZoZUe0Aq5-Inw2qWxvtJ2Cu6ZRN9WPtLWxoK8K3hsYPImMogzpRqIk6QW7OU2o5eXJQCWNBrM0f5AqYg_gJi8qB0nexe45U9ERIQXTffFnPS8tnxFwbOWpLjH7p1wi6yU1W3FtfIgAqzK7P1VIUZnXDR00wHx5FHLGt5vNPx03bKOq1LNcVNAPrbaIeSygItsWifdpDiAQujNH9TJj2nztgiPnzjLBsahfF5nKAzqJ2zR7PU_dnQjkyifhASpnewdTK7ZSaVJTJ9cgJOb6Baw9adFH4BQ23vX_97w2S3K8tczJO0doT_8vunNsq0ptDIULcVLRYzVDAf_hF6vHHHne_wvu3U47pCBmYVBvYXElBflw3bOk9TVlw_pXragbAh6iyKoPWglrJu5UX13an9L54K5jEt7O58l1dW7bwuLCK6SfD_isUPQOn3o4KQfypfFYAfl9Wnllq4Sn--tLQgzf7jt_KYDjDpl1VVm2tfJF-9TuD4vkfGM6y6b2hXYo7g1b22bcKbhi_cfZrB_bvm0zMsPA0k4VAUGX8z20JIX8r3xhyJfP2d1kREprEEumHlb-CB63WrlPY9HKlFDCBg13UrEXC8RB1vYAY-vI65Fa6DyDMLsrbBDglMBK00HPrCt11lwC1lK8K6oT4pOJKsYew_EDoi0bCIAdq3JzUS8-_1bYPQ5b3jmMzapka5A0jPpdLxmOiZzKpCpHMVYbu6ZAYlGx8cK6YMcOJc6xES3FXF7ZrlaGND7fPQb7NIFy20Q7TG51fAQTo24tWISJMh0z5RsGZ95aenYSaYaT1Iw72Ecaz-rCBwDIGvSmDRf0TAjhJtb9TabGxf1U6xWxWzuYEmqDNJ31psDLuHMXYQ6UFFrx9EmUElIPL_LaxIQWGaQx5WOxiIIA0g2o0dxX6uDuFAKHX4y1x9t6z9JDvT7Efsv7Q7FhvI4ipA4tBzOtU7pynKstY9_4WwwOAfzOTasabOg95PqCYZgvkz_AqDBso-SnGFOZCKaWPXHtByrVD2kAU_MQb0ouBgIgUP0MthGsa3vEcJcr31uDZlESxYOV-3egvVCVQC6wpK3iFB5cnti09NIWr2TLWmx9Iy12-szLbU-LDpyq4lbqJXXKZl2_9OUYRJqUQghv_sU-fnlKOk9nu_55BZ1fJn46Ljx3t5dPFiyQDKAWatOnIyyJMiAoNCKgtsZRwtNszdMbW6w0gkwiTlQM2ZHkAJIUqWku-bdOuNYNM8Rv7Xxbl6YigLVjthQcax3QmYxxqBuF8lKlogjdl0u_FwN-Yv9Kl9CBsDPrj4to_pe3i7SvraAspJcKXBTbyGoFWwUNsq2Uj_M2jvzyEkzAlut_dQl2CurCVNTYyH1bkWuTdbtIHfHMT-COVj4gSijdtAy8k-1TklOD1s8J00YQbPoo_xneQaBAFF_tOtSg2fY0-ZCDMr2Pmn-8QPFsOUaZgAQDbwpjqrEeIE-QhvSyd4OBrUnCqQnb4G2z1PSkc_I-yhNUQmL5cBrwiBFAk3ta572GvvKp5L1h1OW9gqDVTRiHpOC3lzkMzRlummQFeEfcIZUjpim_Mh81ObL83xFzgqyXZIPwGfQ4mRWsXrM8sz6IbBcinugclK_ibTUfcoSRc863IQcei9GKNvsYBm26Gz0oxJ5LU8d3Bk1ZDmVGPzr60bEHGRIWmbJy_QcAA3ZjQYAVyFn6bN_rjHKOQPHYxn7KcbiW8fISwEY5N4O9di1nAAU0A3vChSHgejE38xwGbEU856Vu1Tm6WDsOZ7P6nvSY0Wa2VUUzRuC_OTmfosD5dI4QhkahMC6NGpLk7uGx2wWzddgJtyfYhUa8bF1tTX8EBzKbaALVIuLdTy20dxb6Nyv3MBCPmbxGJQOxHpEuVunp5Ww3IXrjjoiH3gjZ6n9mFn8DpzmQtwwL1BW0tj-qMEK6lCyTIY94dzqv8YDv8MA4mIZDUXDE32KzjDyZoYB-K4hZriYb2EuNmf23j-aGTeKYbp1yjABiiFumtzaV5VkAmQecCW4dG8RrhjUAH5tMqC6H6zgghuHcecPl7iFYlB2VVXJaDVNebo6aNbunpVEa-h55nk-4YXtqMw3_e8cu_bCe2RmzPzzdHFjno8WB_nLIHak296YCVhpnn6R3hzEyX-aK1H7tMsT6myiPMWogwAc6K_dpaB5ibn_eawkuycjSig5Lp40o6dnWNqqkEi2AgmdBELW6L0GZ1sWPr_Ke0CWL1GSLXqB8K5wg9H-TDy9pvQDq0nhzUeIHdCniNyXhNLuK0MbZtHpWpDBifGOxtIzwmFEgPGqgihqVl_8CLlaAoBF8UgRuN-ocNROh3jX-YI3wJ5bsClCM89x5LjW9MNkDaPQYqjg2ZV74apJbI1vdmuJaM2xHDE83KkZtp1nOMKlBj75uwzEN2EFxLNaXkAAPaLvmCjb73kEATeAlUIIdDYAGcmvpsudDUu1NNyIG36gCu7uyxo8LhTT5fohXaR8E0RZMUecLDK7o0euZp9yqTfHZtyDJHArzHUa4kbuOebDNRXlH---21TfP0hTsiqVXaX1guwzyJVSAWrz4VmVoVO7SpETEOqBQmtqcdb1Y8vwkAYfrGapE1bDUo8_UGRXTGL2WUWEh_8eFDldQ8JeM-bPPQRypaEeMaGq7ksFc0M0WuyeD-eib12khRyk4c8h55yqeg0uSeyqFSndJRN4rQsuaMW41NBepTOULIoxoxRH6W5OsiTz_oCp3rrqYuThaNqmlXdxKLQILS0sQIEIA0ltkOFOekftU7X0QyNlkfqKlyQAHEmngCzfMLxEkVWv8xYEnoaNUx6WQBGHPdfI7frD4oNZYhVGVifArhv_TMdSjskB2dhmzJCA87voODg3OaFNuJaAS_uyftfGFq_YS8bczZL8nt20eSC2AqvisW0_8RyFDDgXCXZJVilNngFozGlS1Gyd-9V86JBxSasIACaxDbhIsTZ3ZOZVP-UlVouNpiBbmusUa-YyXFGa7YP_XCgquUnIP3C6zqmaWFj3B69UFJPP-QQbcMU2gY7wliP1mYEno1jZq7y7ad68ZZp_JQpLmnywo_3oTnrdU8t6dUuSBoUUT1FzX7OffYAT4brwTYAuLjK63IbXcYuRifi9HDzUCrc4Elld5F-N-r_NbcYQdlZkKl_E9jt7Zl25clVhKz3Cpg9VpLSjUq7wCAvCeT1k5rUWVq5dc361jpoampqNje8AED4wO7B4vzKcY5fCyWfeQUvncU7RoJHN6csxpZduklDo0mO_2FX9pvq2_9NhIcVj3MBKzPuSoKkTnycxu-88Xcw9XZKM7va8-koEwJ69NMmSf3eoHBx81DSeBDhA1zpMNRHj-0SkhdprB3HbznPN-vjNK1WEU33Hidkaertj-ymeekShkYIG5npkZBfjePVd7QekJXuXXP7ITCOHIvZ21Kz6vI9LfyCa-e67HG1q2JYz3ffwLk5R3gyLHxj1f-TfRcjm7xQ0CHAfpASnrV4YxT4qAFC-8XwB6m2qSHcfxuEmnjmNahRfPnRe3t2cq_crRw4ZnZEvuFfn0ohLMspGzbNQXsQEcK0tHF4CFAM3z9hvb2ZNsD3Ie5LkVapQZAfFh1WxPZbAw4EH_w_5n1AcbJXSqZAEPHdIo9yT8yjgJC5M70v26UGAC52JsvcMRhrAe2y4vstLYrtn2JHQ8W2iQtUoI_DHvrHLs80AxwazQ5KQDaZkCiVLRAkMo1iN94bQQkAx3zHenRtfdVWjR0GgErblo7YVe-ukycqZK3VCDYrL5iuH-qQDRRgCufBCCPoYqLnkllOJfazwo82rphsf5g94dbzEOF-7gUadqJF1j1W8Sg9hwSft-kDjeD6yEoNzEDvgYGHUiVXHXhgKLp5eGl05Vp1Q-X4x_Ho1RWcMm8jB9iqlw4-gn3ry-WXXRLGq7sotb-VhWpQEhsUxMGWywKNpWu06rglAyo4Of8iGGfKSrHLf5ehCIgGy_Bu7TElFT1MAh0BHeRDhK5PiufFF_lUrTHpk94FmWJcXFj1G8C1kkUHIrHMydOKPzLxcOCAjc4XQhAvl_jLql6S-XdnDWWalyV0n2OtwW8gPI9xwD7t2aQTH4KsFT6ioNfk-ZS_YuPZE8ZzjN7s1IPkJGswL79gKYlvqunCctrGrHyO8lHEED7c7hXzB8OcrjXdgxEFc-aqxKhjwL3sc7fGVp8XALcInAmFy4bJAxUPH3FghFhek5k4z-klJMvTz55tJ89ppUIzXe7YfoqAIsNC0ItN3W_9dwhGBlWr7H7Z3C4TesRkZ9P_w0CoHniL6Bsyytzj2f4LLdSNE3CDRTwc-9pucasSDJF_dsSwk6F2cQi5FqovazPizCpyRpW07EufJgwarYG1mct8VWmG0EjPwmLKjgRHPACzZ0Tz4baeuHiCxY267zIte0pFcEroGaOJ3mShAfj-DV81FDGuoO5Sv7iKLOmat75eJ4tY1r7a0gK6ndphyL5TtBXznlh6T-Gkp6vmARxc814E257W172Ior43AzV4HTXgn_tIdzq1eHFCo62ZsUljKIova9W88ZEY-7gE84zHjVAAGcVAVuDcLjEVlmzWUhsMewZFjSwRcNNdICLCnuHoLbnirQzK9FbWVCUmsP5A2nwcHov_QdMRNQ3TfxAguSh7u2dyiniDPLJzeyk8u5-8EcsUfPpX_ZcmOn_D1lbpWegkSMEIRY46su2w8q9IO0gl9X1C9Sn0Fl6uMLhwP0uKzjNXGBT1UxgVaxXoObftrAm8S-0swQIl8uquoHk-awUL1zMnBjXnsK3a34jmHvYUM4HcGbNj0NmCDbBcwFo5elKBvOtd18wGMHV2wjO_cRqnG3P3LQd2sTY7Y70iuhwtx8OMZ1rBbWNkuUXJEGByihsNwGiNM1wNzjypbQbd8yl9b4pZQm_3aTvKEx5bwYvd18VLegfSWxaWq3hDjNf8HdWnpM3UrGtX0c8e3AhdOtE2kVxK1tEjzZLMwrDLIVe4XFsAK5LaiPn2t_-kTJ01yGOOi9DCHqmCzGdohWwMRtnILcKT_xw_HT6sQRBih6mpnPVp_I8H6mKuuSrwXvhfa096XbnpTVskrq9k1qHFJ0_eWqXMeNAUUyWSUVBkfEMy5j0_cR4CKi9Ot8V9CoaSf5Vq7YgSxA5tvN15b5G7co3UBIrEy794x_ikn7SQg56yUhvGWh-y59GxAEl50anXI8yJvZXYJ83y4BLO0ukdz587vDsNnAhPS3n9-6tX1QWaXsITsmx-4bc_GIy4DgE41EOSkRhAzumONnhb7v8nkNwoYmA97L4pl6KnRjcOw2Gm70T9Sr-mebCEk_5VVbX6YlELNy9R19TKzWK0F7ZaUePbQpS0H2tkCio_OkQ8i5BDvj_ghZaDskXLJpNA86KCaPztWJ0F0QQKJJHcWDz2kuU7fCKJLCZ9c_bwXR17HF5vv0jVUiZnB-m2xR6UR2vSB3FX_ZNITmCNfnSgVXLm3Damp_ChsYKS-A==

class Node:

    def __init__(self, v):
        
        self.value = v
        self.prev = None
        self.next = None

class LinkedList2:

    def __init__(self):
        
        self.head = None
        self.tail = None

    def add_in_tail(self, item):
        
        if self.head is None:
            self.head = item
            item.prev = None
            item.next = None
        else:
            self.tail.next = item
            item.prev = self.tail
        self.tail = item

    def find(self, val):
        
        node = self.head
        while node is not None:
            if node.value == val:
                return node
            node = node.next
        return None

    def find_all(self, val):
        
        listing = []
        if self.head is None:
            return listing
        node = self.head
        while node is not None:
            if node.value == val:
                listing.append(node)
            node = node.next
        return listing

    def delete(self, val, all=False):
        
        if self.head is None:
            return None
        else:
            node = self.head
            while node is not None:
                if node.value == val:
                    if self.head.value == val:
                        self.head = self.head.next
                        if self.head is None:
                            self.tail = self.head
                            return
                        self.head.prev = None
                        if all is True:
                            node = node.next
                            continue
                        else:
                            return
                    else:
                        old = node.prev
                        while node.value == val:
                            node = node.next
                            if node is None:
                                old.next = None
                                self.tail = old
                                return
                            if all is True:
                                continue
                            else:
                                old.next = node
                                node.prev = old
                                return
                        old.next = node
                        node.prev = old
                node = node.next

    def clean(self):
        
        self.__init__()

    def len(self):
        
        length = 0
        if self.head is not None:
            node = self.head
            while node is not None:
                length += 1
                node = node.next
            return length
        else:
            return length

    def insert(self, afterNode, newNode):
        
        if afterNode is None:
            if self.head is None:
                self.head = self.tail = newNode
                return
            else:
                self.tail.next = newNode
                newNode.prev = self.tail
                self.tail = newNode
                return
        else:
            newNode.prev = afterNode
            newNode.next = afterNode.next
            afterNode.next = newNode
            if newNode.next is None:
                self.tail = newNode
                return

    def add_in_head(self, newNode):
        
        if self.head is None:
            self.head = self.tail = newNode
        else:
            newNode.prev = None
            newNode.next = self.head
            self.head.prev = newNode
            self.head = newNode

import unittest

class Test_LinkedList2(unittest.TestCase):

    def test_find_all(self):
        
        self.assertEqual(List.find_all(1), [])
        List.add_in_tail(a)
        List.add_in_tail(b)
        List.add_in_tail(d)
        self.assertEqual(len(List.find_all(1)), 2)

    def test_delete_false(self):
        
        List.add_in_tail(a)
        List.add_in_tail(d)
        List.delete(1, False)
        self.assertEqual(List.head.value, 1)
        self.assertEqual(List.tail.value, 1)
        self.assertEqual(List.len(), 1)

    def test_delete_true(self):
        
        List.add_in_tail(a)
        List.add_in_tail(d)
        List.delete(1, True)
        self.assertEqual(List.head, None)
        self.assertEqual(List.len(), 0)

    def test_clean(self):
        
        List.add_in_tail(a)
        List.clean()
        self.assertEqual(List.head, None)
        self.assertEqual(List.tail, None)

    def test_len(self):
        
        self.assertEqual(List.len(), 0)
        List.add_in_tail(a)
        List.add_in_tail(b)
        List.add_in_tail(c)
        self.assertEqual(List.len(), 3)

    def test_insert(self):
        
        List.insert(None, b)
        self.assertEqual(List.head.value, 2)
        self.assertEqual(List.tail.value, 2)
        List.clean()
        List.add_in_tail(a)
        List.add_in_tail(b)
        List.insert(None, c)
        self.assertEqual(List.tail.value, 3)

    def test_add_in_head(self):
        
        List.add_in_head(a)
        self.assertEqual(List.head.value, 1)
        List.add_in_head(b)
        self.assertEqual(List.head.value, 2)

    def tearDown(self):
        
        List.head = List.tail = None

if __name__ == '__main__':
    
    a = Node(1)
    b = Node(2)
    c = Node(3)
    d = Node(1)
    List = LinkedList2()
    unittest.main(verbosity=2)
